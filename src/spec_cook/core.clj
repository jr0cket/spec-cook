;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Title: spec-cook
;;
;; Description:
;; Trying out clojure.spec and clojure.spec.test at the
;; Thoughtworks London Clojurians dojo (November 2016)
;;
;; Specification & generative testing for recipes type and
;; cooking function.  Inspiration from lambdaisland.com
;;
;; Required Clojure 1.9.0 or greater
;;
;; author:  @jr0cket
;; date:    29 November 2016
;; license: Creative Commons Attribution Share-Alike Int. 4.0
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(ns spec-cook.core
  (:require [clojure.spec :as spec]
            [clojure.spec.test :as stest]))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Specification and test for recipe type
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define what we want as an example valid recipe
(def recipe
  {::ingredients [1  :kg "aubergine"
                  20 :ml "soy sauce"]
   ::steps       ["fry the aubergines"
                  "add soy sauce"]})


;; Define a bad recipe, one that should not conform to the spec
(def recipe-bad
  {::ingredients []
   ::steps [1 2 3]})

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Specification around recipe
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Is our recipe a map?
(spec/conform map? recipe)
(spec/conform map? recipe-bad)


;; More specifically, does the map have keywords & vectors?
(spec/def ::recipe
  (spec/map-of keyword? vector?))

;; Lets test our recipe against this spec
;; spec/valid? returns true or false
;; Use conform to returns the value of the thing being
;; checked when true, or spec invalid if false
(spec/valid? ::recipe recipe)
(spec/conform ::recipe recipe)

(spec/valid? ::recipe recipe-bad)
(spec/conform ::recipe recipe-bad)


;; Are the steps a collection of strings?
;; And is that collection a vector?
(spec/def ::steps
  (spec/coll-of string? :kind vector?))

;; Lets test our recipe again
(spec/valid? ::steps (::steps recipe))
(spec/valid? ::steps (::steps recipe-bad))


;; Each ingredients list can have one or more ingredient
(spec/def ::ingredients
  (spec/+ ::ingredient))

;; Each ingredient should conform to...
(spec/def ::ingredient
  (spec/cat :quantity number?
            :unit     keyword?
            :name     string?))

;; Lets test our recipe has one or more ingredients (one or more valid ingredient)
(spec/valid? ::ingredients (::ingredients recipe))


;; Redefine ::recipe spec to require ingredients,
;; but steps are optional
(spec/def ::recipe (spec/keys :req [::ingredients]
                              :opt [::steps]))

;; Test our updated recipe specification
(spec/valid? ::recipe recipe)
(spec/conform ::recipe recipe)

(spec/valid? ::recipe recipe-bad)
(spec/conform ::recipe recipe-bad)

;; Recipe-bad failed, so lets see why
;; (check repl for output)
(spec/explain ::recipe recipe-bad)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A simple cook function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn cook
  [recipes]
  (str "need to check I get a valid recipe, then cook it"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Specification and test for cook function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Function specification for cook
;; The argument must be of spec ::recipe
(spec/fdef cook
           :args (spec/cat :recipe ::recipe)
           :ret string?)

;; By instrumenting the function, its checked when it is called
(stest/instrument `cook)

;; This will fail with an explanation generated by spec.test
(cook "fish")

;; Using a valid recipe as an argument,
;; cook should return the result of the function
(cook recipe)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
